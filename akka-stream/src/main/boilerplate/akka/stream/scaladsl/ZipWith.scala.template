/**
 * Copyright (C) 2014 Typesafe Inc. <http://www.typesafe.com>
 */
package akka.stream.scaladsl

import akka.stream.impl.Ast.FanInAstNode
import akka.stream.impl.Ast
import akka.stream.impl.Ast.Defaults._

object ZipWith {

  [2..#/**
   * Create a new anonymous `ZipWith` vertex with 1 specified input types.
   * Note that a `ZipWith` instance can only be used at one place (one vertex)
   * in the `FlowGraph`. This method creates a new instance every time it
   * is called and those instances are not `equal`.
   */
  def apply[[#T1#], C](f: Function1[[#T1#], C]): Zip1With[[#T1#], C] =
    new Zip1With[[#T1#], C](f, OperationAttributes.none)#
  ]
  
  final class Left[A, B, C] private[akka] (private[akka] val vertex: Zip2With[A, B, C]) extends JunctionInPort[A] {
    type NextT = C
    override private[akka] def port = 0
    override private[akka] def next = vertex.out
  }

  final class Right[A, B, C] private[akka] (private[akka] val vertex: Zip2With[A, B, C]) extends JunctionInPort[B] {
    type NextT = C
    override private[akka] def port = 1
    override private[akka] def next = vertex.out
  }

  [#final class Input1[T1, C] private[akka] (private[akka] val vertex: ZipWithBase[C]) extends JunctionInPort[T1] {
    type NextT = C
    override private[akka] def port = 1
    override private[akka] def next = vertex.out
  }#
  ]

  final class Out[C] private[akka] (private[akka] val vertex: ZipWithBase[C]) extends JunctionOutPort[C]
}

/**
 * Takes two streams and outputs an output stream formed from the two input streams
 * by combining corresponding elements using the supplied function.
 * If one of the two streams is longer than the other, its remaining elements are ignored.
 */
private[akka] final class Zip2With[A, B, C](override val f: (A, B) ⇒ C, override val attributes: OperationAttributes) extends ZipWithBase[C] {
  val left = new ZipWith.Left(this)
  val right = new ZipWith.Right(this)

  override def minimumInputCount: Int = 2
  override def maximumInputCount: Int = 2

  // FIXME cache
  private[akka] override def astNode: FanInAstNode = Ast.Zip2With(f.asInstanceOf[(Any, Any) ⇒ Any], zip and attributes)

  private[scaladsl] final override def newInstance() = new Zip2With[A, B, C](f = f, attributes.withoutName)
}

[3..#/**
 * Takes 1 streams and outputs an output stream formed from the two input streams
 * by combining corresponding elements using the supplied function.
 * If one of the two streams is longer than the other, its remaining elements are ignored.
 */
private[akka] final class Zip1With[[#T1#], C](override val f: Function1[[#T1#], C], override val attributes: OperationAttributes) extends ZipWithBase[C] {
  [#val input1 = new ZipWith.Input1[T1, C](this)#
  ]

  override def minimumInputCount: Int = 1
  override def maximumInputCount: Int = 1

  // FIXME cache
  private[akka] override def astNode: FanInAstNode = Ast.Zip1With(f.asInstanceOf[Function1[[#T1#], Any]], zip and attributes)

  private[scaladsl] final override def newInstance() = new Zip1With[[#T1#], C](f, attributes.withoutName)
}#
]
