##############################
# Akka Reference Config File #
##############################

# This the reference config file has all the default settings.
# Make your edits/overrides in your akka.conf.

akka {
  version = "2.0-SNAPSHOT" # Akka version, checked against the runtime version of Akka.
  
  home = ""                # Home directory of Akka, modules in the deploy directory will be loaded

  enabled-modules = []     # Comma separated list of the enabled modules. Options: ["cluster", "camel", "http"]

  event-handlers = ["akka.event.Logging$DefaultLogger"] # Event handlers to register at boot time (Logging$DefaultLogger logs to STDOUT)
  loglevel        = "INFO"                              # Options: ERROR, WARNING, INFO, DEBUG
                                                        # this level is used by the configured loggers (see "event-handlers") as soon
                                                        # as they have been started; before that, see "stdout-loglevel"
  stdout-loglevel = "WARNING"                           # Loglevel for the very basic logger activated during AkkaApplication startup
                                                        # FIXME: Is there any sensible reason why we have 2 different log levels?

  logConfigOnStart = off                                # Log the complete configuration at INFO level when the actor system is started. 
                                                        # This is useful when you are uncertain of what configuration is used.

  extensions = []          # List FQCN of extensions which shall be loaded at actor system startup. 
                           # FIXME: clarify "extensions" here, "Akka Extensions (<link to docs>)" 

  # These boot classes are loaded (and created) automatically when the Akka Microkernel boots up
  #     Can be used to bootstrap your application(s)
  #     Should be the FQN (Fully Qualified Name) of the boot class which needs to have a default constructor
  # boot = ["sample.camel.Boot",
  #         "sample.rest.java.Boot",
  #         "sample.rest.scala.Boot",
  #         "sample.security.Boot"]
  boot = []

  actor {
    provider = "akka.actor.LocalActorRefProvider"
    creation-timeout = 20s           # Timeout for ActorSystem.actorOf
    reaper-interval = 5s             # frequency with which stopping actors are prodded in case they had to be removed from their parents
    timeout = 5s                     # Default timeout for Future based invocations
                                     #    - Actor:        ask && ?
                                     #    - UntypedActor: ask
                                     #    - TypedActor:   methods with non-void return type
    serialize-messages = off         # Does a deep clone of (non-primitive) messages to ensure immutability
    dispatcher-shutdown-timeout = 1s # How long dispatchers by default will wait for new actors until they shut down

    deployment {
    
      default {                # deployment id pattern, e.g. /app/service-ping

        router = "direct"      # routing (load-balance) scheme to use
                               #     available: "direct", "round-robin", "random", "scatter-gather"
                               #     or:        fully qualified class name of the router class
                               #     default is "direct";
                               # In case of non-direct routing, the actors to be routed to can be specified
                               # in several ways:
                               # - nr-of-instances: will create that many children given the actor factory
                               #   supplied in the source code (overridable using create-as below)
                               # - target.paths: will look the paths up using actorFor and route to 
                               #   them, i.e. will not create children

        nr-of-instances = 1    # number of children to create in case of a non-direct router; this setting
                               # is ignored if target.paths is given

        create-as {            # FIXME document 'create-as'
          class = ""           # fully qualified class name of recipe implementation
        }

        target {
          paths = []           # Alternatively to giving nr-of-instances you can specify the full paths of 
                               # those actors which should be routed to. This setting takes precedence over
                               # nr-of-instances
        }
        
      }
    }

    default-dispatcher {
      type = "Dispatcher"              # Must be one of the following
                                       # Dispatcher, (BalancingDispatcher, only valid when all actors using it are of the same type),
                                       # A FQCN to a class inheriting MessageDispatcherConfigurator with a no-arg visible constructor
      name = "DefaultDispatcher"       # Name used in log messages and thread names.
      keep-alive-time = 60s            # Keep alive time for threads
      core-pool-size-min = 8           # minimum number of threads to cap factor-based core number to
      core-pool-size-factor = 8.0      # No of core threads ... ceil(available processors * factor)
      core-pool-size-max = 4096        # maximum number of threads to cap factor-based number to
                                       # Hint: max-pool-size is only used for bounded task queues
      max-pool-size-min = 8            # minimum number of threads to cap factor-based max number to
      max-pool-size-factor  = 8.0      # Max no of threads ... ceil(available processors * factor)
      max-pool-size-max = 4096         # maximum number of threads to cap factor-based max number to
      task-queue-size = -1             # Specifies the bounded capacity of the task queue (< 1 == unbounded)
      task-queue-type = "linked"       # Specifies which type of task queue will be used, can be "array" or "linked" (default)
      allow-core-timeout = on          # Allow core threads to time out
      throughput = 5                   # Throughput defines the number of messages that are processed in a batch before the
                                       # thread is returned to the pool. Set to 1 for as fair as possible.
      throughput-deadline-time =  0ms  # Throughput deadline for Dispatcher, set to 0 or negative for no deadline
      mailbox-capacity = -1            # If negative (or zero) then an unbounded mailbox is used (default)
                                       # If positive then a bounded mailbox is used and the capacity is set using the property
                                       # NOTE: setting a mailbox to 'blocking' can be a bit dangerous, could lead to deadlock, use with care
                                       # The following are only used for Dispatcher and only if mailbox-capacity > 0
      mailbox-push-timeout-time = 10s  # Specifies the timeout to add a new message to a mailbox that is full - negative number means infinite timeout
    }

    debug {
      receive = off        # enable function of Actor.loggable(), which is to log any received message at DEBUG level
      autoreceive = off    # enable DEBUG logging of all AutoReceiveMessages (Kill, PoisonPill and the like)
      lifecycle = off      # enable DEBUG logging of actor lifecycle changes
      fsm = off            # enable DEBUG logging of all LoggingFSMs for events, transitions and timers
      event-stream = off   # enable DEBUG logging of subscription changes on the eventStream
    }
    
    # Entries for pluggable serializers and their bindings. If a binding for a specific class is not found,
    # then the default serializer (Java serialization) is used.
    #
    serializers {
      # java = "akka.serialization.JavaSerializer"
      # proto = "akka.testing.ProtobufSerializer"
      # sjson = "akka.testing.SJSONSerializer"
      default = "akka.serialization.JavaSerializer"
    }

    # serialization-bindings {
    #   java = ["akka.serialization.SerializeSpec$Address",
    #           "akka.serialization.MyJavaSerializableActor",
    #           "akka.serialization.MyStatelessActorWithMessagesInMailbox",
    #           "akka.serialization.MyActorWithProtobufMessagesInMailbox"]
    #   sjson = ["akka.serialization.SerializeSpec$Person"]
    #   proto = ["com.google.protobuf.Message",
    #            "akka.actor.ProtobufProtocol$MyMessage"]
    # }

  }

  # Used to set the behavior of the scheduler.
  # Changing the default values may change the system behavior drastically so make sure you know what you're doing!
  #
  scheduler {
    # The HashedWheelTimer (HWT) implementation from Netty is used as the default scheduler in the system.
    #
    # HWT does not execute the scheduled tasks on exact time.
    # It will, on every tick, check if there are any tasks behind the schedule and execute them.
    # You can increase or decrease the accuracy of the execution timing by specifying smaller or larger tick duration.
    # If you are scheduling a lot of tasks you should consider increasing the ticks per wheel.
    # For more information see: http://www.jboss.org/netty/
    tickDuration = 100ms
    ticksPerWheel = 512
  }
  
}
